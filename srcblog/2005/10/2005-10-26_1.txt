Date: 2005-10-26 19:19:17
Format: wphtml
Title: Code-name Monad and the value of different perspective

ArsTechnica <a href="http://arstechnica.com/guides/other/msh.ars/1" title="wrote another excellent review">wrote another excellent review</a>, this time of upcoming Microsoft Windows Shell, code-name Monad.<br/> <br/> It's a really cool shell, it blows every other shell in existence out of the water. But this is not a link-blog, I provide commentary and what Monad made me think about is the value of different perspective.<br/> <br/> The first Unix shell <a href="http://en.wikipedia.org/wiki/Thompson_shell" title="has been developed in 1971">has been developed in 1971</a>, 34 years ago. Bash, currently the most widely used shell on Unix was <a href="http://en.wikipedia.org/wiki/Bash" title="developed in 1987">developed in 1987</a>, a slight improvement over <a href="http://en.wikipedia.org/wiki/Bourne_shell" title="1977 Bourne Shell">1977 Bourne Shell</a> (thank god for whiskey and Wikipedia).<br/> <br/> The most popular Unix shell, default on Linux, Mac OS X and most other Unix versions, isn't much better than it was 30 years ago.<br/> <br/> Open-source evangelists often argue that open-source is better than closed source because openness brings experimentation, experimentation brings improvements. They also argue that openness creates an evolutionary way of writing software, where lots of changes in divergent directions ultimately converge on the best solution, may the best piece of code win. The problem with this view is:<br/> <ul>  <li>  I don't want to wait a million years for a usable piece of software; I need it yesterday</li>  <li>  evolution created humans so it must be great. But it also created pigs and, when you think about it, compared to humans everything else is a failure; I don't want software whose quality is comparable to the relative quality of a pig</li>  <li>  you can only stretch a metaphor that much before it breaks. Software doesn't have DNA, what might work for nature doesn't have to work for software.</li> </ul> <br/> The fact that Monad is so much better than bash is a slap in the collaborative, evolutionary theory of software development.<br/> <br/> If evolutionary way of writing software really is superior, then bash should be a shining example. It's not an obscure utility no-one cares about - it's an essential part of Unix.<br/> <br/> It's not like no-one tried to improve the shell - we have Korn Shell, C Shell, zsh, scsh (Scheme-based shell), Rsh, PWB Shell, Es shell, Almquist shell, tcsh. Instead of advancing the default they mostly succeeded in creating head-aches for system administrators.<br/> <br/> During all this time all Microsoft had was cmd.exe, a sorry excuse for a shell, a glorified DOS box.<br/> <br/> So how come a few Microsoft programmers, in just few years, leap-frogged 34 years of vigorous mutation and cross-breeding of Unix shells?<br/> <br/> I have a theory:<br/> <ul>  <li>  the power of different perspective</li>  <li>  the power of vision backed up by focused effort</li> </ul> <br/> It's genuinely hard to come up with something better if there's a strong history of good enough. It's hard to develop a different perspective.<br/> <br/> Unix shells are good enough and Unix heads for years derided Windows for its clearly inadequate cmd.exe and claiming the superiority of Unix' "lots of little tools, connected" philosophy. Coming from a position of superiority, it's easy to become complacent and dismiss many flaws in shell approach:<br/> <ul>  <li>  number of shells in popular use causes more problems that it solves</li>  <li>  shell is a really weak programming language</li>  <li>  forking a processes to get a list of files is inefficient<br/></li>  <li>  programs can only communicate via arbitrary, irregular text streams<br/></li>  <li>  which is why we have hacks like awk. Please mommy, don't make me decipher awk scripts again, I'll be good, I promise</li>  <li>  some simple and frequently done things like grepping through files matching a given pattern in all sub directories of a given directory often require syntax so complex that I don't even bother to remember what it is</li> </ul> <br/> Apparently all Unix programmers prefer to adapt to those problems than fix them once and for all. Microsoft, on the other hand, re-thought the problem and fixed all those messy problems.<br/> <br/> I might write about the power of vision backed up by focused effort later.<br/> <br/> And just in case you like to draw your own conclusions: please don't. This is not "close source is better than open source" article. The world is not black and white. There is some good open source and some good closed software. There is shitty open source software and there is shitty closed source software. If there's one grand conclusion to be drawn here about open source is that it works, but for reasons different than what the popular meme on the subject is.<br/> <br/>